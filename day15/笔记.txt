IO = Input / Output


     读入  / 写出


    读入、写出，都是相对于内存来讲的。
    读入：把外部的数据读取，放到内存里面。内存里面使用变量来存储数据。
        比如QQ收取到的聊天信息，属于从网络“读入”。
        比如从硬盘上打开一个视频文件，看电影。从硬盘读入。

    写出: 把内存里面的数据，写出到外部的其他存储设备，比如硬盘、网络等。
        比如QQ发送信息出去给好友，属于把数据写出到网络。
        比如复制一个文件到U盘，首先要从一个源读入放到内存中，然后再把内存的数据写出到U盘。


所有输入对象，都会有对应输出对象。
    比如 InputStream ，表示一个字节输入流。
         OutputStream，表示字节输出流。


流
    表示连续不断的数据流。


IO的类，都在 java.io 包下面。



InputStream
    read  : 从输入流数据中读取数据放到内存。如果输入流还没有可用的数据，read方法会阻塞、等待。
        返回数据中的内容。如果读取到文件的结尾，返回-1。
    available : 返回流里面还有多少个可用的字节数。
    close : 关闭流。
    


OutputStream
    write : 把一个字节写到文件中。如果要写出字符，必须把字符转换为byte数字。
    close : 关闭流。
    flush : 把流里面的数据，刷出到目标。在调用close方法的时候，会自动调用一次。
            如果想让对方收到完整的数据，又不想关闭流的时候，必须调用一次flush。
            如果没有关闭流，也没有调用flush，那么对方可能会在比较久之后才收到完整的数据。



特别注意：
    一定要养成良好的习惯，自己创建的流，必须自己关闭！
    在Java 7以后的代码中，建议使用try-with-resources语法，自动关闭。


流从操作的数据来看，分为两大类：
    字节流
        Stream结尾的，都是字节流！

    字符流
        读取的时候，使用Reader；写出的时候，使用Writer


流从使用的构造器来分，分为两大类
    节点流、基本流，构造器参数，如果是物理资源的话，那么这个流，就是节点流。
        FileInputStream/FileOutputStream 直接操作文件，文件就是物理资源。
        ByteArrayInputStream/ByteArrayOutputStream 直接操作字节数组，也是节点流。
        CharArrayReader/CharArrayWriter 节点流。


    处理流、高级流，构造器参数，如果是另外一个流的化，那么这个流就是处理流。
        BufferedInputStream/BufferedOutputStream 的构造器需要另外的流作为参数，所以是处理流。
        InputStreamReader/OutputStreamWriter     也是处理流。



File对象
    表示一个文件。在计算机系统里面，不管是文件夹，还是电影、MP3等，全部都是文件！


    使用File对象来表示一个文件。比如文件的路径是 D:\io\a.mp4
    File f = new File("d:/io/n.mp4");

    文件的路径，使用 / 来进行分隔不同的目录。Windows虽然默认使用 \\ ，但是在Java里面，可以统一使用 /

    构造器
        File(File parent, String child)  : 提供一个父目录(parent)，child可能是一个子文件、子目录。
        File(String pathname)            : 使用一个路径，构建一个File对象。
        File(String parent, String child): 其实和第一个构造器是一样的

    常用方法
        getAbsolutePath()  : 返回File对象表示的绝对路径
        mkdir()            : 把File对象指定的路径，创建一个目录出来。如果File对象本身就已经是一个文件或者目录，返回false。
            如果File对象的上级目录，不存在，返回false。

            返回false，表示创建目录没有成功。

        mkdirs()           : 和mkdir是相同的作用的。mkdirs，会判断上级目录是否存在，如果不存在，会自动创建上级目录！
        getName()          : 返回文件名。如果是文件夹，返回最后的文件夹的名称；如果是文件，返回文件的名称，包括扩展名。
        exists()           : 判断File对象表示的文件是否存在，如果存在返回true。
        delete()           : 删除File对象表示的文件。
        deleteOnExit()     : 在程序退出的时候，才执行删除文件。
        isDirectory()      : 判断File对象表示的文件，是否为一个目录。
        isFile()           : 判断File对象表示的文件，是否为一个【文件】。
        isHidden()         : 是否隐藏文件。
        lastModified()     : 文件的最后修改时间，毫秒记。
            Date d = new Date( f.lastModified() );

        length()           : 返回文件的长度（大小）。以字节记。
        list()             : 如果File对象表示为一个目录，list()方法返回目录中的下一级内容。返回String[]，里面是File的路径。
        listFiles()        : 如果File对象表示为一个目录，listFiles()方法返回目录中的下一级内容。返回File[]。
            FileFilter : 表示文件的过滤器，用来把需要的内容过滤出来。
            FilenameFilter : 文件名过滤器，使用文件名判断是否为需要的内容。

        renameTo(File dest): 重命名文件。相当于是Windows里面的剪切、黏贴功能。
        toURI()            : 把File对象，转换为URI类型的对象。URI 是【统一资源标识符】。
        listRoots()        : 把硬盘中的所有根目录全部列出来。



流重定向
    System.setErr
    System.setOut






练习
    1.基于字节流，实现一个文件的复制。

    步骤：
        1.确定要复制的源文件
            /home/data/workspace/teaching/2.teach/J1604/JavaSE/day15/02-输入、输出流的简单使用.mp4

        2.确定把源文件复制到哪个地方(存储目标)
            /tmp/io/a.mp4


        3.分别创建输入流、输出流

        4.读取源文件，把读取到的数据放在内存中的一个变量里面。


        5.把读取到的数据，写出到目标文件。


    2.基于前面的练习，优化性能
        合适大小的缓冲，能够有效提高程序的I/O性能。

        字节流里面使用缓冲，非常简单，继续使用原来的read、write方法，只是原来操作的数据是int类型的，表示一个字节。
        现在缓冲是一个字节数组，表示很多个字节。


        假设现在字节数组的大小是1K，意味着每次最多读取1024个字节进来、写出也是最多每次写出1024个字节。

        步骤
            1.原来read的时候，只是使用了无参的read方法，现在改为需要byte[]的参数的方法。
                这个方法是把数据读取放到byte数组里面，尽量填满byte数组。
                方法的返回值表示读取了多少个字节放到数组里面。
                方法返回-1表示，没有读取到任何数据、流结束了！

            2.原来write的时候，只是写出一个字节，现在需要改为把byte数组里面的数据写出。
                写出的时候，不能完整的把数组写出，必须按照read方法返回的字节数来写。

    3.找到JDK的文档中，文件名中包含【Stream】的文件。
        步骤
            1.确定JDK文档的路径
                String name = "/home/data/documents/java/javase-8-api-docs";

            2.使用路径创建一个File对象
                File file = new File( name );

            3.获得File对象里面名字包括 【Stream】的内容。
                注意文件夹和普通的文件的区分。
                如果是文件夹，则需要继续找下一级；如果是文件，则直接判断文件名是否包含Stream。
                需要使用递归

            查询到的文件，简单输出绝对路径。


        递归：
            方法自己调用自己！

            public void test()
            {
                test();
            }

            无限递归，一定会导致 StackOverflowError 。
            每调用一次方法，就会分配一个栈内存。内存不是无限大的，所以无法无限制分配栈内存。
            StackOverflowError 就是在栈内存被用光以后，出现的错误。

            递归的两个基本规则：
                1.沿着固定的方向，比如一直找下一级目录。
                2.要有结束、不递归的时候。比如文件的时候，就不能再递归下一级。


    4.找出文件夹中，所有大小最小为2K的文件（大于或等于2K的文件）。
        2 * 1024


    5.删除文件夹中所有文件名的扩展名是css的文件
        需要使用文件名判断即可


    6.复制一个目录
        复制目录的时候，把目录中的所有内容全部复制一遍。

        需要递归源目录中所有的子目录。
        在目标目录，需要根据源目录的结构创建一样的目录结构。

        目标目录里面，创建了目录以后，还需要复制和源目录中相同的内容的文件。












