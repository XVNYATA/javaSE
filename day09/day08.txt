子类继承父类，能不能继承父类的私有字段？


代码块
    使用大括号包起来，放到类里面的代码。
    代码块可以放到代码的任何地方，包括方法、构造器、类等里面。
    放到方法里面的代码块，是局部代码块。
        //在最后一个分号的时候，for结束，后面的大括号就是一个局部代码块，和for循环没有任何关系！
        for(int i = 0; i < 10 ; i++);
        {
        }

        //if后面的大括号，也可以认为是if控制的代码块
        if(...)
        {
        }

    初始化代码块 : 放到类里面的代码块。在程序执行之前，会先执行的代码块。
        类初始化代码块

         有static修饰的代码块

            【第一次】主动使用类的时候，就会执行【一次】类初始化代码块。在类加载到内存后，立即会执行初始化代码块。
            在内存里面，一个类只会被读取一次。

            作用
                在使用类之前，需要先完成一些初始的动作，这些初始的动作就放到初始化代码块里面。
                很多类可能都只有静态方法，每个静态方法都可能需要使用到公共的一些资源，比如数据库信息，公共的信息从初始化代码块进行初始。

        实例初始化代码块
            没有static修饰的代码块

            在【每次】调用构造器【都】之前执行一次。
            实例初始化代码块被插入到构造器之前。
            如果有继承父类，父类的初始化代码块会在调用父类的构造器之前执行一次。


            作用
                把多个构造器里面重复的代码，提取到代码块里面，方便所有的构造器使用。有助于提高代码的重用度。



封装类
    在Java里面有八种基本数据类型，这些数据类型全部都不是面向对象的。这八种数据不具备对象的特性。
    但是Java又是面向对象的编程语言，为了统一编程风格，对八种基本类型的数据提供了封装类。

    比如人的年龄还未设置的时候，如果是int，默认会是0，但是这不科学！没有设置的时候应该是null，不应该是0！

    基本类型的封装类，全部都是引用类型，可以为null。


        byte   -> Byte
        short  -> Short
        int    -> Integer
        long   -> Long
        float  -> Float
        double -> Double
        boolean-> Boolean
        char   -> Character


    在Java 5之前，要把基本类型转换为封装类型，必须调用构造器，或者对应valueOf方法，把基本类型转换为封装类型的。
    在Java 5之后，直接赋值就可以了——自动装箱。


    //手动装箱
    Integer i1 = new Integer(50);
    //自动装箱
    Integer i2 = 50;


    //自动拆箱
    int i3 = i2;
    //手动拆箱
    int i4 = i2.intValue();


    所有的封装类里面（除了Character外），都有parse开头的方法，这个方法是负责把字符串转换为基本类型的。
    经常用户输入是字符串，但是实际需要基本类型。比如用户在浏览器输入转账金额。

        String input = "12043.44";
        double amount = Double.parseDouble(input);

        int i = Integer.parseInt(input);


    建议尽可能使用封装类型，这样可以保证编程风格的一致。



Object
    是所有类的祖宗，所有的都是对象。
    任何类都直接或者间接继承Object。

    继承了Object，Object里面的方法，在任何类都可以使用。

	toString()         : 把对象转换为String,返回该对象的字符串表示。
	理解：告诉使用者我是什么？
            默认情况下，格式为：
                <类名>@<hashCode的十六进制>
                Human@15b8f3c

            建议使用格式：
                类名[成员变量名=成员变量值, 另外成员变量名=值]


	面试题：
	java中"=="和"equals"有什么区别？
	答：==符号比较的是对象的内存地址。
	   equals比较的是对象的内容是否相等。
	   如果两个对象==判断返回true，那么两个对象的hashCode一定相等。
	   但是两个对象的equals判断返回true，有可能hashCode不相等，注意，这里指的是两个对象的hashCode不相等。

        equals(Object obj) : 比较两个对象是否相等(内容)。所有的引用类型的比较，都必须使用equals方法进行比较。
            实际上Object里面的equals方法比较两个对象是否相等，还是在比较内存地址。
            子类里面为了能够使用自己的规则进行比较，都需要重写equals方法，比如String类里面就重写了equals方法。
            自己写的类，要比较两个实例是否相等，必须自己重写equals方法。


        hashCode()         : 可以简单的认为，hashCode就是内存地址。
            hashCode是一个int值，是根据对象的内容使用哈希算法计算得到的。
            如果两个对象使用equals进行比较的时候返回true，那么两个对象各自的hashCode方法返回的值也应该是相同的。
            默认情况下，Object类里面的hashCode返回的是对象的内存地址。


        getClass()         : 返回当前实例是由哪个类产生的。在Java里面，类也是对象。
            所有的类，都是Class的实例。




static关键字详解
    static是一个标记
        有static修饰的表示[类]成员
        没有static修饰的则表示[实例]成员

    Java类的成分包括成员变量、方法、构造器、初始化块、内部类，除了构造器外，都可以用static修饰

静态变量：
    有static修饰的成员变量是类变量，类变量作用域：
        类在一个java命令里面，只会加载一次，只要类存活，类变量也存活。
        类变量的作用域是在整个java命令范围。

	当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份，例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。



    静态方法：
        静态方法是类方法，和对象无关，可以直接用类调用。

	1.在静态方法里只能直接调用同类中其它的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。

	2. 静态方法不能以任何方式引用this和super关键字。与上面的道理一样，因为静态方法在使用前不用创建任何实例对象，当静态方法被调用时，this所引用的对象根本可能就没有产生。

	3.main() 方法是静态的，因此JVM在执行main方法时不创建main方法所在的类的实例对象，因而在main()方法中，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在以后的例子中会多次碰到。

     理解main方法
	public static void main(String[] args)
	由于java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数。



    所有static修饰的成员，都会存在整个java命令范围内。基于这个原理设计出了单例模式。


设计模式
    前人总结的，用于解决特定问题成功的解决方案。
    使用各种设计模式“可保证项目具有更好的通用性、可扩展性。”


单例模式 Singleton
    在一个java命令里面，不允许一个类有多个实例的情况。
    假设现在有一个类，创建实例的时候，需要5分钟，为了避免重复创建这种成本很大的实例，必须限制类的实例的数量。
    重量级对象（创建时加载的数据很多，耗时）在整个项目中只加载一次。

    实现单例模式的步骤
        1.私有构造器
            禁止其他人通过new调用构造器
        2.使用一个静态的成员变量，保存当前类唯一的实例
            自己调用构造器产生一个实例
        3.使用一个公共的静态方法，返回静态变量。
            静态变量表示的就是类唯一的实例。

        单例模式：单实例模式




final关键字
    修饰符，可以修饰
        类，表示类不能被继承。
            Object类绝对不可能是final的，因为所有的类最终都继承自Object。
            JDK里面有大量的类是不能继承的，包括System、String、Class。
            当类已经很完善的时候，为了避免继承通过重写方法的方式，把好的代码改坏了！所以这种类可以用final。
        方法
            表示方法不能被子类重写。
        局部变量
            表示不能被再次赋值。局部变量必须程序员手动赋值才能使用的，所以使用final修饰基本上没有变化。
            在Java 8之前，局部变量如果要被局部内部类、匿名内部类使用，局部变量必须是final的，java 8的时候会自动把局部变量变成final。
        成员变量
            表示不能被再次赋值。如果成员变量使用final修饰，程序员必须给成员变量赋值，系统不会自动赋值。

            修饰类变量，类变量必须在以下两个地方对类变量进行初始化赋值。
                1.直接在声明变量的时候赋值。
                2.在使用静态代码块，给变量赋值。

            修饰成员变量，必须在以下三个地方对成员变量进行初始化赋值。
                1.声明的时候直接赋值。
                2.使用非静态代码块给变量赋值。
                3.使用构造器给变量赋值。



abstract关键字
	Java中可以定义一些不含方法体的方法，它的方法体的实现交给该类的子类根据自己的情况去实现.这样的方法就是抽象方法，包含抽象方法的类就叫做抽象类。一个类中可以有一个或多个抽象方法。
	A、抽象方法只需声明，而不需实现。含有抽象方法的类必须被声明为抽象类，抽象类的子类必须覆盖所有的抽象方法后才能被实例化，否则这个子类也必须声明为抽象类。
	B、抽象类不能实例化(即就是不能用new关键字去产生对象)，抽象类的作用就是为了被继承
	C、抽象类可以包含具体方法
	D、当一个类继承抽象类时，必须实现抽象类中的所有抽象方法，否则，这个子类也必须声明为一个抽象类
	注意：含有抽象方法的类肯定是抽象类，而抽象类不一定包含抽象方法.


    修饰符，可以修饰
        类  ，表示类是抽象的，不能new，用于被继承。抽象类里面可以没有抽象方法。
        方法，表示方法是空的，不能用，用于被子类重写。抽象方法必须放到抽象类里面。

    有final的地方，不能有abstract。

    修饰类：抽象类
	    为任何类加上abstract可变成了抽象类
	    特征
		    得到：抽象类可以拥有抽象方法，但并不是必须拥有抽象方法
		    失去：创建对象的能力。抽象类不能直接new一个实例。抽象类用于被继承,但是抽象类的引用可以指向子类实例，多态。
	    抽象类的构造器的作用
		    不用于创建对象
		    主要用于被子类的构造器通过super()来调用
	    抽象类的作用
		    定义变量
		    定义方法
		    派生子类
		    相当于是一个类模板
	    继承抽象类的规则
		    要么重写父类的所有抽象方法
		    否则该子类必须再次定义为抽象类



    修饰方法：抽象方法
	    特征
		    只有方法签名，没有方法体
		    用abstract修饰的方法
	    作用：用于被子类重写
	    abstract和static不能同时修饰方法
            static的方法不能被子类覆盖（重写）。
            static的方法是类方法，属于类的，永远通过类进行调用。
            static的方法，不具备多态的特性。


模板模式  Template
    当大部分的工作在父类都能够确定，只有小部分不确定时候，把不确定操作定义为抽象方法，交给子类去实现。


工厂模式  Factory
工厂模式就是在声明的时候不知道到要什么对象 在使用的时候再实例化！采用接口或者基类调用！
以提高代码的复杂度为代价来增强灵活性、可复用性,维护的时候非常方便.
它为系统结构提供了灵活的动态扩展机制.

Farmer(农夫)  Fruit(水果)  产品(Apple、Banana、Orange)

1. 简单工厂
让对象的调用者和对象创建过程分离，当对象调用者需要对象时，直接向工厂请求即可。
从而避免了对象的调用者与对象的实现类以硬编码方式耦合，以提高系统的可维护性、可扩展性。
工厂模式也有一个小小的缺陷：缺点是当产品修改时，工厂类也要做相应的修改。
有个农夫，可以种植水果(苹果、香蕉、桔子)使用简单模式完成

2. 工厂方法
当使用(factoryMethod)工厂方法设计模式时，对象调用者需要与具体的工厂类耦合：
当需要不同对象时，程序需要调用相应工厂对象的方法来得到所需的对象
对于采用工厂方法的设计架构，客户端代码成功与被调用对象的实现类分离， 解耦合
但带来了另一种耦合：客户端代码与不同的工厂类耦合

3. 抽象工厂(AbstractFactory)
具体产生哪个水果则由Farmer抽象工厂决定，
不同的参数将产生不同的Fruit对象。通过采用抽象工厂的设计模式，
系统可以让客户端代码与被调用对象的实现类、具体的工厂类分离。


重点
    1.Object类
        重写equals、toString、hashCode方法
    2.static、单例模式
    3.final关键字
    4.abstract关键字


作业：
1.熟悉封装类：基本类型和封装类型的转换、
把字符串转换成基本类型、把基本类型转换成字符串
2.写一个类，使用final进行修饰类、方法、变量
3.定义一个Person类，重写Object的equals、toString、hashCode方法
4. 写熟单例模式

5.写一个类，使用abstract修饰类
定义一些抽象方法，交给子类实现
定义一些非抽象的方法，是所有子类共用的方法实现，并且把方法声明成final的









