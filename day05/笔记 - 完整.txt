“自加”的陷阱
    自加和自减规则是一样的，这里只是以自加为例。


    int i = 1;
    // i++ 的返回值是1
    // 执行 i++ 以后，i的值是2
    i = i++;
    System.out.println( i );// 1


    for( int x = 0; x < 5 ; x = x++ )
    {
        System.out.println( x );//0
    }



使用JDK自带的API对数组进行复制和扩容
    数组复制和扩容的时候，之前使用自己循环进行复制和扩容，效率低、代码重复多。


    java.util.Arrays类，是专门用于操作数组的一个工具类。

    复制 : 是一个动词。只要是动词，那么在Java里面一定是方法！

    API的阅读方法
        1.通过方法名找到方法
        2.如果出现多个同名的方法，那么使用的时候，系统会自动调用和参数的数据类型最接近的方法
        3.方法需要哪些参数，那么必须传入相应的参数
            比如 copyOf(int[] ori, int length)
            这样第一个参数是 int[] 类型的变量，第二个参数则是一个 int 类型的变量。
        4.如果在方法名的左边一列，出现 static ，表示静态方法，此方法可以被直接使用。
        5.如果在方法名的左边一列，出现非 void 之外的其他数据类型，那么表示方法有返回值。
            比如 
                public static int[] copyOf(int[] original, int newLength)

            表示 copyOf 方法是静态的，第一个参数是 int[] ，第二个参数是 int 。调用方法会返回一个 int[]


            所以调用copyOf方法的正确姿势：

                int[] ori = new int[]{1,2,3,4,5,6};

                // 把ori数组复制产生一个新的数组，并且新数组的长度为20。
                // 方法会产生一个新的数组，并返回，所以需要在左边使用等号把返回值赋予给一个变量保存起来。
                // 因为方法的返回值类型是 int[] ，所以等号左边的变量的数据类型必须是 int[] 。
                int[] arr = Arrays.copyOf( ori, 20 );

                System.out.println( arr.length );//20

                for( int x : arr )
                {
                    // 输出6以后，会输出一堆的0
                    System.out.print( x );
                    System.out.print( "," );
                }


    Arrays.copyOf方法，可以作为数组的复制使用，也可以作为数组的扩容使用，甚至可以缩减数组容量。
        1.如果新数组的长度和旧的数组长度一样，表示完全的复制
        2.如果新数组的长度，比旧的数组长度要长。表示扩容。
        3.如果新数组的长度，比旧的数组长度要短。表示缩减容量。


    Arrays.copyOfRange方法，则是可以把旧数组的部分内容复制到新数组的方法。

        copyOfRange(int[] original, int from, int to)

        original 表示原始数组
        from     表示从原始数组的第几个元素开始复制，第一个元素使用0。from是索引。from是包括的。 >= from
        to       表示复制到原始数组的第几个元素。to不包括。< to


        // 1,2,3,4,5,6,7,8,9  => 1,2,3,4,5
        Arrays.copyOfRange( ori, 0, 5 );


        注意： to必须比from要大，并且to不能大于原始数组的长度。


对数组里面的元素，进行排序

    冒泡
        像水里的水泡一样，越往上，水泡就越大。

        在排序的时候，比较相邻的两个元素，比较大的，移动到右边，把小的移动到左边。

        1.循环数组长度减一次，把最大的数放在最右边
            1.1.循环
            1.2.比较相邻的两个数字
            1.3.如果左边的比右边的大，交换位置


        2.完成第一步以后，只是完成了第一轮比较，把最大的一个数放到最右边
            现在需要继续完成多轮循环，循环的轮数，是数组的长度减一次。

        3.修改内层循环的循环条件，原来只是 i < arr.length - 1，现在需要再减去外层循环的计数器。
            第一轮循环的时候，外层的计数器（y） 等于0，内层相当于还是 i < arr.length -1 - 0
            第二轮循环的时候，外层的y=1，内层相当于 i < arr.length - 1 - 1
            第三轮循环的时候，外层的y=2，内层相当于 i < arr.length - 1 - 2

        TestBubbleSort.java
        TestBubbleSort2.java

    使用API排序
        简单的排序
            TestArraySort.java

        Java 8的并行排序
            TestArrayParallelSort.java



找到1000以内的所有完全数
    所有真约数之和，等于本身的，就是完全数。
    真约数，小于本身的约数。
    约数，能够把一个整除的数字，这些数字都是约数。

    现在有数字6,6的约数包括 1\2\3\6，1\2\3、就是真约数。
    1 + 2 + 3 = 6，所以6就是完全数。


    步骤：
        1.循环1~1000
        2.在循环里面，嵌套一个循环，用来找到外层循环计数器的真约数
        3.在内层循环里面，把内层循环的计数器相加，得到真约数之和
        4.判断真约数之和，是否和外层循环的计数器相等


    TestPerfect.java


把一个数组元素的顺序倒过来
    把数组里面元素的顺序，全部倒过来

    TestReverse.java


输出三角形

    每行的空格数 = 总行数 - 行号
    每行的星号数 = 行号 * 2 - 1


    步骤：
        1.循环 “总行数” 次
        2.在循环里面，先循环输出空格
        3.继续在循环里面，循环输出星号
        4.空格和星号都输出以后，换行

    TestTrangle.java


输出空心三角形
    在输出星号的地方，加上一个判断：
        是否第一行或者最后一行。如果是则直接输出星号。否则输出空格，并且在空格前后加上星号。
        中间的空格数量，是星号数量 - 2，因为前后有星号。

    TestEmptyTrangle.java


随机且不重复字符，A-Z的任意6个
    TestRandomChar.java



随机且不重复字符，包括A-Z、a-z、0-9等62个字符中的任意6个
    TestRandomAllChar.java



一级重点
    1.数组的复制 TestArrayCopy.java
    2.冒泡排序   TestBubbleSort.java
    3.随机且不重复的字符数组 TestRandomChar.java


二级重点
    1.使用API排序 TestArraySort.java  TestArrayParallelSort.java










