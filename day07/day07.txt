eclipse快捷键：

1. alt + /  万能快捷键
2. control + c  复制
3. control + x  剪切
4. control + v  粘贴
5. control + f  查找
6. control + d  删除
7. control + alt + ↓  复制一行


构造器/构造方法
    可以认为构造器是一种特殊的操作（方法）。
    构造方法是类构建的时候由编译器执行的.我们是不能调用的
    现有对象还是先执行构造器?
    1.创建对象分配空间 
    2.给属性赋初值 
    3.执行构造方法(根据参数) 
    4.返回实例给引用变量
    构造方法负责做一些对象创建后的初始化工作
    构造方法其实是有返回值的,
    它隐式返回一个本类的对象给到引用变量(使得外部可以访问)
    用于被new关键字调用，用来产生实例（对象）。
    语法基本上和方法差不多，只是：
        构造器没有返回值类型，因为构造器永远返回当前类的实例。
        构造器没有独立的名字，构造器的名字必须和类名完全相同。
        修饰符只能用public | protected | private，不能有static、final之类的。

    构造器也可以有参数，和方法一样。


    注意点
	    无论如何，一个类至少会有一个构造器
	    不能定义没有构造器的的类
	    如果程序员没有给类定义构造器，系统会默认生成一个没有参数的构造器
	    如果已经定义了有参构造器，系统不会生成无参构造器
	    一个类，可以有多个构造器，但是参数必须不同

☆构造器详解
    类必须有构造器，如果程序员没有自己写构造器，系统也会生成一个没有参数的构造器。建议一定显示写上无参构造器。

    一个类里面可以有多个构造器，但是参数列表必须不同。

    一个类如果有多个构造器，就构造器重载。
    不同的形参列表
	    √形参的类型不同
	    √形参的类型相同，但是形参的个数不同
	    √形参的类型、个数都相同，但是形参的顺序不同
	    ×形参类型、个数、顺序都相同，但是参数的名称不同
	    ×形参类型、个数、顺序都相同，但是构造器的修饰符不同

    构造器中使用this调用
	    只能调用当前类中重载的构造器。
	    到底调用哪个构造器，完全取决于传入的参数。
	    this()调用必须位于【构造器】执行语句的【第一行】？
	    构造器中不能使用递归，如果有递归编译不通过
	    this调用的作用
		    避免重复的初始化代码，出现在多个构造器中——提高代码的复用度

    如果程序员写了有参构造器，系统不会再生成无参构造器。


面试题：
构造器是创建java对象的途径，是不是说构造器完全负责创建Java对象？
	答：不是！我们通过new关键字调用构造器时，构造器确实返回了该类的对象，但这个对象并不是完全由构造器负责创建的。
	实际上，我们调用构造器时，系统会先为该对象分配内存空间，并为这个对象执行默认初始化，这个对象就产生了，这些操作都是在构造器执行之前完成的。也就是说，当系统执行构造器之前，系统已经创建了一个对象，只是这个对象还不能被外部程序所访问，只能在该构造器中通过this来引用它。当构造器执行结束，这个对象作为构造器的返回值被返回，通常还会赋给另一个引用类型的变量，从而让外部程序可以访问该对象。


package关键字
    为了解决避免出现同名的类。使用package关键字，不同的package里面的类生成的class会放到对应的文件夹里面。
    建议从今天开始，所有的类一定要写package。
    语法
        必须在java源代码的第一行写package关键字。
        package <包名>;


        包名:
            使用标识符就可以了
            通常建议使用公司的域名倒写 (fkjava.org  => org.fkjava)
            域名上面就有点，这些点就会变成子目录 org/fkjava

        现在一个公司有三个部门，这三个部门的代码里面，都有一个User.java的文件，放到不同的包，怎么放呢？
        信息化部门的域名  oa.fkjava.org
            package org.fkjava.oa;
        互联网部门的域名  inter.fkjava.org
            package org.fkjava.inter;
        微信产品部门的域名 weixin.fkjava.org
            package org.fkjava.weixin;

        现在需要把三个部门所有的代码，合并到一个项目里面。项目名称叫做 proj
            proj
                |-- src : 源代码
                    |-- org
                            |-- fkjava
                                |-- oa
                                    \-- User.java
                                |-- weixin
                                    \-- User.java
                                \-- User.java
                            \-- TestUser.java
                \-- build : 编译后的class文件
                    |-- org
                            |-- fkjava
                                |-- oa
                                    \-- User.class
                                |-- weixin
                                    \-- User.class
                                \-- User.class
                            \-- TestUser.class

        源代码的目录，用于存储java文件，所有包对应的目录，必须手工创建。
        class文件的目录，则直接可以自动根据包名生成目录，不需要手工创建。但是必须在javac命令后面加上 -d 的参数。


        
☆import关键字
    把其他包下面的类导入到当前代码，用于缩短类名。
    当然也可以写包名.类名

    import关键字必须放到package之后，第一个class之前。

    在一个源代码里面，严禁导入同名的类。同名的类在缩写后，系统无法识别。

    //导入一个具体的类，建议用这种。
    import <包名>.<类名>;

    import java.util.Arrays;


    //导入一个包下面所有的类
    import <包名>.*;


    系统会默认自动导入java.lang下面的所有类。


从Java 5之后，提供了静态导入。用于把其他的类的静态成员导入到当前类来使用。
    import static <包名>.<类名>.<静态成员名称>;
    import static <包名>.<类名>.*;
    import static java.util.Arrays.toString;

    只看成员的名字，如果当前类有同名的成员（不管是否静态），都不能用静态导入把另外的静态成员导入进来。



面向对象编程语言的三大特性
    ☆封装
        合理隐藏，合理暴露，使具体实现不可见;
        比如人里面有一个年龄，人的年龄只能是1~150之间。但是给成员变量进行赋值的时候，可以给任意的值，值变得不符合实际的情况。
        为了保证类似的情况，不至于发生脱离现实的事情发生，就需要把细节隐藏起来，暴露安全的操作给调用者。

        为了隐藏和暴露，Java提供了四个权限
            公共权限     : public
                在任何地方都可以访问
            受保护的权限 : protected
                只能在当前包、当前类、子类里面可以访问
            包权限       : 不写修饰符，默认权限
                只能在当前包、当前类访问
            私有权限     : private
                只能在当前类访问

	四个权限什么时候使用呢？
	1. 作为封装，建议字段使用private，不希望暴露给外界调用的方法写成private
	2. 方法一般写成public
	3. 希望子类可以访问的成员可以写成protected


	实现封装：
	1、字段使用private修饰（不希望暴露给外界的成员用private修饰）在定义一个类的成员（包括变量和方法）时，使用private关键字说明这个成员的访问权限，这个成员成了类的私有成员，只能被这个类的其他成员方法调用，而不能被其他的类中的方法所调用。
	2、方法使用public修饰（提供给外界使用的成员用public修饰）为了实现良好的封装性，我们通常将类的成员变量声明为private，再通过public的方法来对这个变量进行访问。对一个变量的操作，一般都有读取和赋值操作，我们分别定义两个方法来实现这两种操作，一个是getXxx()（Xxx表示要访问的成员变量的名字），用来读取这个成员变量操作，setXxx()用来对这个成员变量赋值。

	JavaBean命名规范里面规定，对于自定义类型的属性property，
	getter和setter方法就是getProperty和setProperty（第一个字母变大写，前面加get或者set）。
	注意，对于boolean的属性，getter方法还默认写为isProperty（getProperty仍然可用，但是jsp默认访问isPropery）。
	例如：
	private boolean fly;
	应该写成：public boolean isFly();
	private boolean isFly;
	应该写成：public boolean isIsFly();
	所以建议boolean类型的属性不要用"is"作为开头来命名。

面试题：
	实现封装的优点：
	1.隐藏类的实现细节；
	2.让使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；
	3.便于修改，增强代码的可维护性；
	4.使类的设计者与使用者分离，使用者无须了解类的设计细节就可以获得类的功能，避免用户错误地使用数据
	一个类通常就是一个小的模块，我们应该让模块仅仅公开必须要让外界知道的内容，而隐藏其它一切内容。我们在进行程序的详细设计时，应尽量避免一个模块直接修改或操作另一个模块的数据，模块设计追求强内聚（许多功能尽量在类的内部独立完成，不让外面干预），低耦合（尽量少的依赖外部程序或对象）


    ☆继承
    在现有类的基础上构建新的类。当继承一个现有类时，就重用(继承)了那个类的方法和属性，同时，还可以向新类中增添新的方法和属性。通过继承可以简化类的定义 ，实现代码重用。

        子类继承父类，子类会得到父类的一切，除了私有的。

        在一个类里面，私有的成员和构造器，都是私有的。

        动物是一个类，必然有构造器。
        动物表示的范围很广，如果要更具体的，就需要子类来描述，比如猪或者是鸟，也都是一个类。
        动物的构造器，无法创建猪或者鸟的实例，必须要用猪或者鸟的构造器，才能创建具体的实例。


        [public] [abstract | final] class <类名> [extends 父类]
        {
        }


        规则
	        Java是单继承的，一个类只能继承一个父类，虽然一个类只可以继承一个父类,但是可以间接继承，但是一个父类却可以被多个子类所继承(Animal可以被Pig和Bird继承)。

	面试题：
	Java为什么是单继承，即一个类只能继承一个父类？
	答：Java只能单继承。如果一个类可以同时继承多个父类，那么运行时有可能出现程序的二义性（多个父类中有同名方法）。
	反证法：
	A sayHello("A");
	B sayHello("B");
	C
	C extends A,B
	c.sayHello();


	        所有的类，都是Object类的子类或者子孙类
	        如果没有自己使用extends关键字进行继承，默认继承Object类（所有的都是对象）
	        子类继承了父类，会得到父类的一切field和方法。除private修饰外，其余都可以访问。


        方法重写/覆盖（override） : 当父类的方法，不能满足子类的要求的时候，子类可以定义和父类一样的方法覆盖父类的行为。
	        子类方法与父类方法的方法名相同、形参列表相同。
	        返回值类型相同或更小（子类）
	        子类方法声明抛出的异常相同或更小
	        访问权限要相同或更大。


        super关键字
	Java程序创建某个类的对象时，系统会隐式创建该类父类的对象。只要有一个子类对象存在，则一定存在一个与之对应的父类对象。在子类方法中使用super引用时，super总是指向作为该方法调用者的子类对象所对应的父类对象。
	其实，super引用和this引用很像，其中this总是指向调用该方法的对象，而super则指向this指向对象的父对象。

	   作用：
	   super可用于访问父类中定义的属性
	   super可用于调用父类中定义的成员方法
	   super可用于在子类构造器中调用父类的构造器

            super引用
                和this引用一样，表示当前实例，但是查找范围从父类开始查找。this从当前开始查找。
                this引用从当前类开始找；super从父类开始找。
            super调用
                构造器不能被继承，构造器用于产生当前类的实例。
                在调用子类构造器之前，必须调用一次父类构造器。

                在构造器里面，如果没有使用this调用，会默认生成一个super调用，调用父类的无参构造器。
                如果父类没有无参构造器，子类必须使用super调用传入合适的参数给父类的构造器。

	Super()表示调用父类的构造方法。
	Super()也和this()一样必须放在第一行。如果有this()，就不能在写super();如果有super()，就不能再写this()。
	如果没有定义构造方法，那么就会调用父类的无参构造方法，即super()。

	面试题：
	为什么super([…])和this([…])调用语句不能同时在一个构造函数中出现？
	答：因为this()是调用其他构造器，而其他构造器如果也有this()，则还会调用其他构造器，如果没有this(),则会有super()存在，而同时调用两个super()就会造成程序错误。
	反证法：
	public Dog() {
		super();
		this("旺财","公",2); // 调用Dog的有参数构造器
	}
	public Dog(String name, String sex, int age) {
		super(name, sex, age);
		
	}


                Object
                                 ↑
                Animal
                                 ↑ 
                Pig  最先调用的构造器是Object，其次调用Animal，最后调用Pig


                每个super调用都只能调用直接父类的构造器，不能调用祖父类的构造器。

    ☆多态
        同一个类型的变量，执行相同的操作，呈现不同的行为
	多态分为编译时多态和运行时多态。
        
        在编译的时候，系统只能检查调用方法、成员变量等是否存在，无法实际执行，也没有分配内存。
        运行时，直接通过new创建了对象的实例，那么这个对象可能是一个子类(小类)。

        在等号的左边的时候，就是编译时类型，等号右边的就是运行时类型。

	编译时多态：
        小类对象赋值给大类变量，会自动类型转换。
	如：Person p = new Man();

	运行时多态：
	p.play(); // 执行的是Man的play()方法


☆动态邦定
静态绑定，就是前期绑定，也叫编译期绑定 
编译的时候，已经确切知道调用的是哪个类的哪个方法 。
动态邦定 又叫后期绑定 也叫运行时绑定 。
简单的说 就是在编译的时候不知道具体调用的是哪个方法（是父类的还是子类的，因为继承有个方法重写的问题） 
java默认的是后期绑定，不加特殊的修饰关键字，所有的方法子类都是可以重写的 。
静态绑定是在编译时绑定，而动态绑定是在运行时根据对象的实际情况来选择绑定父类或者是某个子类的方法。在执行效率上，静态绑定要优于动态绑定，但丧失了灵活性。 
Java中变量是静态绑定的，实例方法是动态绑定的。在进行“向上转型”的时候子类会覆盖父类的实例方法而不会覆盖父类的变量


☆对象的类型转换
	A. 子类能自动转换成父类。除此之外，程序还可以直接创建一个子类的实例对象，传递给需要父类的实例对象作为参数的方法，在参数传递过程中发生了隐式自动类型转换。
	理解子类能够自动转换成父类：人是父类，男人是子类
       B. 父类转换成子类需要进行强制类型转换。
	理解父类转换成子类需要进行强制类型转换：一个男人肯定是人，一个人却不一定是男人。在不确定一个人是男人还是女人的时候强行使用男人或女人的特定方法是会出现问题的，所以编译不通过。强制类型转换其实是告诉编译器，我确定这个人是男人或女人。在强制类型转换时，程序员是要对转换完后的后果负责的，也就是要确保在内存中存在的对象本身确实是可以被转换的类型，否则即使编译通过，运行还是会出错的。强制类型转换的前提是程序员提前就知道要转换的父类引用类型对象的本来面目确实是子类类型的。

        大类的对象赋值给小类变量，需要强制类型转换。
	Person person = new Man();
	Man m = (Man) person;

        在强制类型转换的时候，可能会出现转型异常。
        为了解决这个问题，java提供了一个巨长无比的运算符 instanceof

        语法
            <变量> instanceof <类名>

            表示左边的变量，是否为右边的类的一个实例。如果是返回true；否则返回false。

            变量 is instanceof a(n) 类


            限制
	            只有判断的两个类型，有继承关系时才可通过编译，否则编译器会报错：不可转换的类型。
	            运行阶段，当前面的变量实际所引用的对象是后面类或其子类的实例，返回true。

        建议在进行强制类型转换之前，都使用 instanceof 判断一下，避免出现不能转换异常。


面试题：
多态的好处？
答：Java是静态语言，也就是说程序的运行结果是在编译时决定的，
运行时是不可以改变的。那如何让Java语言具有动态语言的特点，
能够在运行时动态改变程序运行的结果呢？
多态性是OOP中的一个重要特性，主要是用来实现动态联编的，
换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。
使用多态就可以在运行时为我们所需要的功能提供不同的实现.
这样可以提高程序的灵活性和扩展性。



☆组合
如果要复用一个类，除了继承之外，还可以使用组合。
组合是把旧类对象做为新类的属性嵌入，用以实现新类的功能。
面试题：
什么时候使用继承？什么时候使用组合？
如果要将一个较为抽象的类改造成能适用于某些特定需求的类，使用继承。如Person 、Student
如果两个类之间有明确的整体、部分的关系，即一个类通过另一个类来完成某个功能，使用组合。如 Person、Car
总之，继承要表达的是一种”是(is-a)”的关系
而组合要表达的是”有(has-a)”的关系

Car Driver

总结：
为了保证父类良好的封装性，设计父类通常遵循以下规则：
1.尽量隐藏父类的内部数据。Private，不让子类直接访问父类的属性。
2.不要让子类可以随意访问、修改父类的方法。父类中那些仅为辅助其他的工具方法，应该使用private访问控制符修饰，让子类无法访问；如果父类中的方法需要被外部调用，必须用public修饰，但又不希望子类重写该方法，可以使用final来修饰；如果希望父类中的某个方法被子类重写，但不希望被其他类自由访问，可以使用protected修饰。
3.建议不要在父类构造器中调用被子类重写的方法。
4.如果某些类不想被子类继承，可以使用final。或者使用private修饰这个类的构造方法，从而保证子类无法调用，也就无法继承该类。





作业：
1.写一个类继承Car，并重写其中的一些方法
2. 设计一个股票类，要具有以下功能：
	记录单笔交易信息
	计算股票的盈亏状况
	应该如何设计字段、方法？
4.深入练习构造器，包括this调用和this引用的使用





