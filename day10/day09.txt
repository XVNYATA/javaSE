
面向对象编程，面向接口编程

接口
    接口就是规范

    在程序里面，接口可以认为是一个特殊的类，里面的方法全部都是抽象方法。
    接口是抽象方法和常量值的定义的集合，从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。
		
    重点：但是接口（规范）和抽象类（模板）的意义就有非常大的区别！！！

        1、接口中所有方法都是抽象方法（abstract关键字可以省略）
	2、接口中可以有属性，所有属性将默认包含public、static、final修饰符
	3、我们可以定义一个新的接口用extends关键字去继承一个已有的接口 ，我们也可以定义一个类用implements关键字去实现一个接口中的所有方法，我们还可以去定义一个抽象类用implements关键字去实现一个接口中定义的部分方法。 
	4、如果一个类实现了某个接口而未能实现接口中定义的所有抽象方法，则该类必须声明为抽象类
	5、一个类可以继承一个父类的同时，实现一个或多个接口，extends关键字必须位于implemnets关键字之前 。(Java多继承的实现)


    接口的语法
        [public] interface <接口名称> [extends 父接口1, 父接口2...]
        {
            //公共的、静态的、最终的成员变量
            //公共的、抽象的方法，没有方法体
            //公共的、静态的内部类

            //在Java 8之后，接口里面可以增加一下两种方法  很少用
            //公共的、静态的方法，有方法体
            //公共的、默认的方法，有方法体
        }




    实现接口的语法
        [public] [abstract | final] class <类名> [extends 父类] [implements 接口1,接口2...]
        {
            //实现接口的时候，要么实现接口里面所有的抽象方法，要么类是抽象类。
        }

        子类继承父类的时候，会同时把父类实现的接口也继承下来。

        类实现接口，相当于也是继承了接口，但是这种继承和extends不同：
            1.实现类要么重写所有抽象方法、要么实现类也是抽象的。
            2.接口是可以多继承的，类不能多继承。一个类也能够实现多个接口。

面试题：

Java可以多继承吗？Java怎么实现多继承？接口为什么可以多继承？
答：Java只能单继承。
    Java通过接口实现多继承。
    A：say(System.out.println("A")) ;
    B: say(System.out.println("B")) ;
    C: c.say();
因为接口中都是方法定义，并没有方法实现。接口避免了C++中多继承的复杂关系所产生的问题(多重继承的危险性在于一个类有可能继承了同一个方法的不同实现，对于接口来说就决不会发生这种情况，因为接口是没有任何实现的)。
接口使得程序更加灵活,最终带来很大的自由.



抽象类和接口的区别和使用场景？
答：抽象类里面用来定义一些公共的功能。抽象类可以理解为一个框架,根据他来派生出活生生的具体的子类.由这些具体的类在派生出新的类来适应新的要求.如果向一个抽象类里加入一个新的具体方法时，那么它所有的子类都一下子都得到了这个新方法.所以通常抽象类通常作为父类存在。
而接口做不到这一点，如果向一个Java接口里加入一个新方法，所有实现这个接口的类就无法成功通过编译了，必须让每一个类都再实现这个方法才行。所以接口更多的做为一种约束行为，即标准、规范存在。


请描述一下Java接口的作用？
接口实际上是定义一个规范、标准。通过接口可以实现不同层次、不同体系对象的共同属性的约束；
以JAVA数据库连接为例子：JDBC制定标准；数据厂商实现标准；用户使用标准。
接口通常用来屏蔽底层的差异。接口也因为上述原因被用来保持架构的稳定性.
而接口(对象必须实现的承诺)与实现(对象如何履行这些承诺)相分离,允许多个类提供相同的功能,允许一个类同时实现多个接口,最终带来很大的自由.


接口里面定义的常量有什么特点？
答：接口就是提供一种统一的”协议”，而接口中的属性也属于“协议”中的成员。它们是公共的，静态的，最终的常量。相当于全局常量。
要变化的东西，应该放在自己的实现类中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。



工厂模式  Factory
工厂模式就是在声明的时候不知道到要什么对象 在使用的时候再实例化！采用接口或者基类调用！
以提高代码的复杂度为代价来增强灵活性、可复用性,维护的时候非常方便.
它为系统结构提供了灵活的动态扩展机制.

Farmer(农夫)  Fruit(水果)  产品(Apple、Banana、Orange)

从前获得对象：new
工厂获得对象：通过工厂去拿

1. 简单工厂
让对象的调用者和对象创建过程分离，当对象调用者需要对象时，直接向工厂请求即可。
从而避免了对象的调用者与对象的实现类以硬编码方式耦合，以提高系统的可维护性、可扩展性。
工厂模式也有一个小小的缺陷：缺点是当产品修改时，工厂类也要做相应的修改。
有个农夫，可以种植水果(苹果、香蕉、桔子)使用简单模式完成

2. 工厂方法
当使用(factoryMethod)工厂方法设计模式时，对象调用者需要与具体的工厂类耦合：
当需要不同对象时，程序需要调用相应工厂对象的方法来得到所需的对象
对于采用工厂方法的设计架构，客户端代码成功与被调用对象的实现类分离， 解耦合
但带来了另一种耦合：客户端代码与不同的工厂类耦合

3. 抽象工厂(AbstractFactory)
具体产生哪个水果则由Farmer抽象工厂决定，
不同的参数将产生不同的Fruit对象。通过采用抽象工厂的设计模式，
系统可以让客户端代码与被调用对象的实现类、具体的工厂类分离。
    



内部类
    类里面的类，就是内部类。
    内部类包括内部类、内部接口、内部枚举等都是属于内部类。

    作用 : 提高程序的内聚

        高内聚
            把相同的作用的代码，封装到一起。
	    对象的功能越强越好。
        低耦合
            不相关的代码，即使要协同工作，也应该降低程序的耦合。
	    对象通常需要和其他对象协同完成工作，那么就产生了耦合关系。
            接口其实就是为了降低耦合而设计的。

    语法和普通的类一样，但是修饰符多了一些，因为有修饰符所以限制也多了一些。


    有static修饰的内部类，称为静态内部类；没有static修饰的，则是非静态内部类。

    内部类和外部类的一些差异性对比
	    修饰符
		    内部类的修饰符多了private、protected、static
		    外部类能用修饰符：public final|abstract，内部类依然可用。
	    静态成员
		    非静态内部类，不能定义静态成员。
		    非静态内部类 ，不允许出现static关键字(但可和final同时出现)

	
    1. 静态内部类  简单了解
        
        1、只能访问外部类中静态的属性和方法。
	2、如果创建对象不需要外部类的对象就可以创建;
	3、可以直接调用静态内部类中的静态方法.
	[外部类名].[内部类名].[方法名]
	4、也可以有非静态的属性和方法;但是在静态方法中不能调用非静态的属性;
	如果需要使用非静态的方法或属性需要对象进行调用；

	何时选择静态内部类:
	 假如更多只是面向第3方客户,而内部外部类相互调用机会较少选择静态内部类。


 
    2. 非静态内部类  简单了解
        当一个类中的程序代码要用到另外一个类的实例对象，而另外一个类中的程序代码又要访问第一个类中的成员，将另外一个类做为第一个类的内部类，程序代码就要容易编写的多。
	1、可以访问外部类中所有的成员变量，所有的成员方法
	2、可以有自己的成员变量；(非静态)
	3、可以有自己的方法.(非静态)
	4、不能有自己的静态属性和静态方法；

	何时选用内部类:
	假如更多是内部外部类相互调用, 很少涉及第3方调用。 选择非静态内部类




    3. 局部内部类  简单了解
        写在代码块（方法、构造器、初始化代码块）里面的类。	
        局部内部类只在定义它的代码段中可见，不能在它所属代码段之外的代码中使用；因此也就没有public/private/default权限修饰符（无意义）。
	唯一需要注意的是：如果局部内部类里面使用局部变量，那么局部变量必须是final的。
	要想使用局部内部类时需要生成对象，对象调用方法，在方法中才能调用其局部内部类。在类外不可直接生成局部内部类（保证局部内部类对外是不可见的）。
	


    4. 匿名内部类（必须掌握）  重点掌握 
	匿名内部类是一种特殊的局部内部类,
        没有自己的名字，不能用匿名内部类声明变量，只能直接new。
	一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类，没有类名，根据多态，我们使用其父类名,结果产生的对象我们可以看成一个实现了这个接口或者继承父类的对象。
	因其为局部内部类，那么局部内部类的所有限制都对其生效。
	匿名内部类是唯一一种无构造方法类。
	如果一个对象编译时的类型是接口，那么其运行的类型为实现这个接口的类。

   匿名内部类的使用：
	代码更加简洁，紧凑，但带来的是易读性下降。
        仅限于类只使用一次的时候使用。通常在使用图形界面的时候，会比较常用，特别是事件处理的时候。

        如果是new是接口，相当于实现接口；如果new的是抽象类、类，相当于是继承类。

             ☆new后面只能跟着一个名字，这意味着匿名内部类，要么实现一个接口，要么继承类，不能同时使用实现和继承。

        如果new的是接口或者抽象类，必须完整实现所有的抽象方法，因为创建类的时候马上就要产生实例，抽象类是不能产生实例的。


        匿名内部类其实也是一种局部内部类。在匿名内部类里面使用外部类的局部变量，局部变量必须是final的。java8之后已经默认final。

	语法：
	 
	 new  接口(){
		// 实现接口的所有方法
	 }


Lambda表达式

     Lambda表达式是Java8的重要更新，支持将代码块作为方法参数，允许使用更简洁
     的代码来创建只有一个抽象方法的接口的实例。

    其实也是一种类似于匿名内部类的东西，但是这种不会生成class文件。
    (形参列表) -> {
        //方法体
    };

    不需要new匿名内部类，不需要指出重写的方法名，也不需要给出重写的方法的返回值类型
   u.processArray(array,
				(int[] target)->{
			int sum = 0;
			for (int i : target){
				sum += i;
			}
			System.out.println(sum);
		});


    Lambda表达式语法
	    形参列表
		    形参列表可以省略形参类型， 而且大部分时候我们都省略
		    如果形参列表只有一个形参，连圆括号都可以省略
		    如果形参列表没有形参、或者有多个形参，圆括号不能省略
	    连接符：   ->
	    代码块
		    如果代码块只有一条语句，可以省略花括号
		    如果被重写的方法需要返回值，而且方法体内仅有一条语句，可以省略return关键字（必须也省略花括号）。

    LambdaQs.java


函数式接口
    只有一个抽象方法的接口就是函数式接口，，为了实现Lambda表达式。从Java 8开始提供
    为了限定函数式接口里面只有一个抽象方法，Java提供了一个注解，这个注解放到接口的上方，这样在接口里面如果有多个抽象方法，编译报错。

    @FunctionalInterface


    限制
	    Lambda表示式只能用于创建“函数式接口”的实例，因为Lambda表达式无需明确指定重写哪个方法。
	    Lambda表示式必须对应一个明确的“函数式接口”，该函数式接口就叫 Lambda表示式 的【目标类型】
            Lambda表达式通过目标类型，自动推断要实现哪个接口的哪个方法。

    指定Lambda表达式的【目标类型】
	    定义变量时类型指定【目标类型】
	    也可【目标类型】进行强制转换。
	    调用方法时根据方法所需参数来确定【目标类型】。


方法引用与构造器引用


本节重点：
1. 什么是Lambda表达式
 (形参列表) -> {
        //方法体
    };
2. 什么是函数式接口



枚举
    在程序里面，很多的对象，都只能有几个有限的实例，比如性别、季节、星期几。为了确保这些类仅能有几个实例。

    自从Java 5之后，Java提供了枚举，把所有的实例列举出来。
    [public] enum <类名> [implements 接口1, 接口2...]
    {
        //在第一行列出所有可能的实例名称，会自动创建实例
    }
	举例：
	public enum SeasonEnum
	{
		// 在第一行列出4个枚举实例
		SPRING,SUMMER,FALL,WINTER;
	}

    枚举类，默认继承了java.lang.Enum类，不能再继承其他类。
    在枚举类里面，构造器是私有的，意味着枚举类不能有子类。
    枚举类的构造器只能是private。

    系统在编译枚举类的时候，会自动加上两个静态方法
        values   : 返回一个数组，里面包含了枚举类里面所有的实例
        valueOf  : 能够把一个字符串转换为枚举对象(实例)。

    枚举本身继承了java.lang.Enum，这里也有一些方法可以被使用。
        name()    : 返回枚举实例的变量名
        ordinal() : 返回枚举实例在第几个声明的，从0开始。相当于枚举实例在数组里面的位置

    switch语句里的表达式可以是枚举值

	Season.java

     
     枚举类也是一种类，一样可以定义成员变量、方法和构造器。

	Gender.java


    如果枚举实现接口，也需要实现接口所包含的方法。
     
     Course.java


    枚举类也可以包含抽象方法，定义抽象方法时不能使用abstract关键字将枚举类定义成抽象类（因为系统自动会为它添加abstract关键字）。简单了解


重点
    接口，就是一个规范，必须要实现才能使用。

    内部类
        静态内部类
        匿名内部类

    函数式接口

    Lambda表达式




作业：
1.写一个类，使用abstract修饰类
定义一些抽象方法，交给子类实现
定义一些非抽象的方法，是所有子类共用的方法实现，并且把方法声明成final的

2.定义一个接口和两个实现类：比如SATA接口的两个可读的设备实现：SSDDisk和HardDisk都实现SATA接口，该接口定义了读、写的方法。写一个测试类使用SATA接口类型的对象。

3.使用匿名内部类的方式，再实现一个SATA接口

4.枚举类，也实现SATA接口，同时在枚举中指定两个枚举值，分别是SSD和HD，代表两种设备


