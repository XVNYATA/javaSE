异常处理
    异常 : 通常是由于意外的操作造成的意外情况。
    异常处理就是把意外情况处理掉，让程序继续执行。


处理语法

    try
    {
        //可能出现异常的代码、语句
    }
    catch( 异常类 变量名 )
    {
        //处理异常的地方，比如提示用户等。
    }



    try
    {
        //可能出现异常的代码、语句
    }
    catch( 异常类 变量名 )
    {
        //异常处理的代码块
    }
    finally
    {
        //不管是否出现异常，最终都一定会执行的代码块
        //通常用于释放资源、关闭数据库连接等操作
    }


    异常的处理注意点：
        1.try代码块表示异常处理的开始，后面可以跟着catch、finally。
        2.如果出现异常，代码会立即终止。如果在try代码块里面出现异常，马上会结束try代码块，并跳到catch代码块。
        3.不管是否出现了异常，都会执行finally。
        4.即使return以后，如果有finally，也会执行finally。
        5.在try、catch里面return的语句会执行，但是返回的数据，会被finally里面return的数据覆盖掉。不建议在finally里面写return。
        6.如果try后面有多个catch，那么必须把范围小的catch放前面。
        7.多个catch的时候，最多只能执行其中的一个catch，因为在try代码块里面出现异常以后，立即会结束try代码块，不会再引发下一个异常。


    异常处理的作用：
        为了提高程序的稳定性、健壮性。



异常体系，所有意外的父类，都是Throwable类。
    异常体系（意外）有两大部分：
        错误，继承Error类的，都是错误。
            通常是指系统出现不可修复的问题，比如内存不足。

            VirtualMachineError 虚拟机错误，java命令发生了错误。
                OutOfMemoryError : 内存不足错误，分配给Java程序使用的内存不足，就会引发此错误。
                StackOverflowError : 栈溢出错误，递归的时候递归太深，就会产生此错误。
                    每调用一个方法，就会分配一个固定大小的栈空间。
                    无限递归的时候，相当于要分配无限的栈空间。内存不是无限的，于是会引发此错误。


            在程序里面，通常不处理“错误”，因为遇到错误，意味着需要调整程序、重启程序。

        异常，继承Exception类的，都是需要程序处理的异常。
            比如读取文件的时候，文件突然中断无法读取，这时候可能是因为文件被改变了位置，或者被删除，导致无法方法。
            这种情况下，可以提示用户，文件无法读取，让用户选择其他的文件来进行处理，程序还是可以继续运行的。

            比如连接网络的时候，无法和服务器进行通讯、通讯超时。这时候可以提示用户选择合适的网络来再次进行操作。
            程序也不需要中断，可以继续执行。


            异常分为两大类
                checked exceptions（已检查异常）
                    Exception和Exception的子类异常，并且排除RuntimeException和RuntimeException的子类异常。
                    已检查异常，要求程序员自己必须处理：
                        要么try catch；要么throws。
                    异常如果一直throws，最终将把异常抛给java命令处理。


                    IOException : 输入、输出的异常，通常是文件读写、网络读写、字符编码等。
                        CharacterCodingException : 字符编码异常。
                        EOFException             : End Of File Exception，读取数据的时候，直接读取到数据的结尾之后。
                        FileNotFoundException    : 文件没有找到异常。
                        UnsupportedEncodingException : 不支持的编码异常。

                    InterruptedException         : 线程被意外中断以后，可能会产生的异常。

                    ReflectiveOperationException : 反射异常。
                        ClassNotFoundException   : 类没有找到异常。
                        NoSuchMethodException    : 没有匹配的方法异常。
                        NoSuchFieldException     : 没有匹配的成员变量异常。
                        InstantiationException   : 通常在通过反射的方式创建一个实例的时候，可能引发此异常。


                    SQLException                 : 使用JDBC的时候，经常容易遇到此异常。


                unchecked exceptions (未检查异常)
                    RuntimeException和RuntimeException的子类异常，都是属于“未检查异常”。
                    这些异常如果程序员没有处理，那么系统默认会自动throws给调用者。如果一直没有处理，最终由java命令处理。


                    NullPointerException      : 空指针异常，如果一个引用类型的变量，等于一个null的时候，访问实例成员，就会引发此异常。
                        int[] arr = null;
                        System.out.println( arr.length );//引发空指针异常

                    IndexOutOfBoundsException : 索引超出边界异常。
                        ArrayIndexOutOfBoundsException  : 数组的索引超出边界异常。
                        StringIndexOutOfBoundsException : 字符串的索引超出边界异常，通常是用索引操作字符串的内容的时候，可能引发。

                    ArithmeticException : 算术异常。

                    ClassCastException  : 类型转换异常。进行强制类型转换的时候，如果实际类型不是被转换的目标类型，会引发此异常。
                        为了避免此异常，尽量强制类型转换之前，先使用 instanceof 运算符判断是否可以被强转。

                    ConcurrentModificationException : 并发修改异常。
                        如果正在使用Iterator遍历一个集合，又使用了集合的add、remove等方法，就会引发此异常。

                    IllegalArgumentException  : 非法参数异常
                        NumberFormatException : 数字格式异常。把字符串使用parseXXX方法，转换为基本类型的时候，可能引发此异常。
                            String x = "abcd";
                            int i = Integer.parseInt( x );

                        PatternSyntaxException : 使用正则表达式的时候，如果表达式不正确，就会引发此异常。

                        UnsupportedCharsetException : 不支持的字符集异常。


        父类，范围比较大。所以称之为“大类”。
        子类，范围比较小。所以称之为“小类”。

        异常也有继承关系，同样具有范围大小的问题。

        try后面，可以跟着多个catch代码块，但是必须把范围小的放在前面！
        异常类型是子类要放在前面。

        否则编译会报错。



异常的处理
    1.捕获异常，并且进行处理，使用catch代码块
        捕获异常以后，可以简单打印异常的栈跟踪信息，也可以再次声明抛出异常。

    2.在方法的声明中，声明抛出异常，不处理，由调用(使用)的地方去处理
        方法的语法：

            [修饰符] <返回值类型> <方法名>( [形参列表] ) [throws 声明抛出的异常列表]
            {
            }

        声明抛出的异常列表
            1.可以声明抛出多个不同的异常，并且不会考虑异常的继承关系。
            2.如果重写父类的方法，并且父类的方法如果有抛出异常的，那么子类的异常要么和父类相同，要么更小。
                方法重写：
                    1.子类继承父类
                    2.子类的方法名、参数列表和父类一样
                    3.修饰符相同或更大
                    4.返回值类型相同或更小
                    5.声明抛出的异常类型，必须相同或更小。子类可以不要声明异常抛出。
            3.如果是unchecked 异常，上面的规则都不考虑，因为unchecked异常可以随便使用。
                特别是继承的时候，只考虑checked异常。



    抛出异常
        throw <异常对象>;

        throw new 异常类型( 构造器参数 );


        throw new NullPointerException("ddddd");


重要的异常方法
    printStackTrace()   : 打印异常栈跟踪信息，可以把异常的整个调用过程，全部打印处理，方便跟踪异常。
    getMessage()        : 返回异常的提示信息。
    getCause()          : 返回异常的原因。如果返回null，表示此异常就是异常的根本原因。
    getSuppressed()     : Java 7新增的方法，表示被抑制的异常对象。


throw和throws的区别
    throw是动词，表示抛出异常对象
        throw 异常对象;
        throw new 异常类型( 构造器参数 );


        RuntimeException e = new RuntimeException();
        throw e;

        throw new RuntimeException();


    throws是形容词，用于说明方法、构造器可能出现哪些异常类型。



自定义异常对象
    当系统自带的异常类型不能满足实际需要的时候，就需要继承异常类，扩展自己的需求。
    比如 账户余额不足，这种异常，JDK绝对不可能有！

    扩展异常的时候，可能继承Exception、RuntimeException，甚至这些异常的子类，都可以扩展。
    如果扩展Exception，那么要求使用的时候，必须处理；
    如果扩展RuntimeException，那么使用的时候可以选择处理或者不处理，比较灵活，异常处理的代码比较少。

    Spring框架的异常处理哲学是扩展RuntimeException。通常在业务中，参考这种方式。
    Hibernate框架的异常处理则大部分扩展Exception。

    比如现在有一个密码错误的异常，密码本身就是参数，密码错误属于参数非法的问题，所以应该继承IllegalArgumentException类。
    IllegalArgumentException类本身就是RuntimeException的子类。


    public class InvalidPasswordException extends IllegalArgumentException
    {
    }

    比如现在有账户余额不足，可以直接继承 RuntimeException 类！

    public class BalanceNotEnoughException extends RuntimeException
    {
    }

    继承了异常类以后，通常需要提供一些异常的信息，需要通过构造器传递进来。
    通常为了满足一些更加复杂的使用环境，会根据父类的构造器，写子类异常的构造器，并且构造器里面只需要super调用父类对应的构造器即可。
    自定义异常，通常不需要在异常类里面增加太多的额外数据。



Java 7以后，对try、catch代码块做了两个优化：

    1.增加了multi-catch代码块
        catch( 异常类1 | 异常类2 | 异常类n...  变量名 )
        {
        }

        不管有多少个catch，始终只有一个catch能够进入处理。
        当有很多个catch的处理，是相同的时候，那么就可以使用multi-catch代码块。

        TestMyException.java



    2.增加了try-with-resources语法
        在Java 7之前，所有的资源，在申请了以后，必须在finally里面释放资源。


        try ( 申请资源 ) 
        {
        }
        catch...
        finally...


        注意点：
            1.申请的资源，必须实现了 java.lang.AutoCloseable 接口。
            2.如果同时申请多个资源，每个资源的中间，必须使用分号隔开。
            3.catch和finally都变成了可选的。
            4.在try代码块完成以后，会自动调用资源的close方法。调用的顺序和申请的顺序正好相反。



        TestTryWithResources.java



一级重点
    异常信息的查看
        调用异常对象的 printStackTrace() 方法可以打印完整的异常栈跟踪信息。

    try catch的语法



二级重点
    Java 7新增的两个语法
    throw和throws的区别和用法










