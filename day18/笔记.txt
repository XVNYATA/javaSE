网络通讯的基本要求：
    IP   : 
        IP目前有两个主要的版本
        IPv4 : 使用32位的整数来表示一个电脑，最多表示42亿的电脑，因为IP是无符号的整数。
            典型的浪费：
                127.0.0.1  永远表示本机，Windows的cmd里面输入ipconfig可以看到此ip。这个ip也被称之为是链路回环地址。
                192 开头，都是属于局域网IP。
                10  开头的，往往是属于城域网的IP。移动内部的网络、长城宽度。
        IPv6 : 使用128位的整数来表示一个计算设备。最多可以表示 2^128 个计算设备，理论上可以为地球上的每个沙子提供一个IP。

        通过域名，找到IP，再通过IP找到电脑。这时候就可以连接到这个IP对应的电脑上面。

    端口 : 为了在一台电脑里面区分很多不同作用的网络程序，给每个程序分配一个数字，这个数字就是端口。
        程序绑定到端口，所有发送到此端口的数据，都会被转发给对应的程序。


        端口被分为三大类
            公认端口  : 需要通过国际上的认证的服务，可以使用公认端口。
                范围是小于1024的端口都是属于公认端口，在非Windows系统必须有root权限才能使用公认端口。
                比如 ftp 服务使用 21 端口和 20 端口。
                比如 http 服务（通过浏览器访问的网站），使用80端口。
                https是安全的、加密的http服务，使用443端口。
                smtp 发送邮件，简单邮件传输协议，使用25端口
                pop3 接收邮件的协议，使用110端口


            注册端口  : 1024~49151，松散绑定一些服务
                随便都可以使用的，只要不和其他程序冲突即可。

                服务端程序在大部分的情况下，绑定的端口都是属于注册端口。

            动态端口/私有端口:49152~65535，应用程序使用的动态端口，一般应用程序不主动使用它，但是类似BT之类的软件通常用这些端口

                客户端连接服务器的时候，需要使用一个随机端口，那么就会使用动态端口。


            端口是一个16位的无符号数字，范围是 0 ~ 65535



    IP太长，不好记。为了方便记忆，于是提供了一个【域名】，域名通过专门的一个map，来实现 名称 和 ip 的对应关系映射。
    map是一个键值对，域名解析的过程，就是通过刚 【域名】 这个键，解析为 【IP】 这个值！
    通讯的时候，只能使用IP来进行通讯，但是记忆的时候通常都是通过域名来记忆的！
    域名解析服务器也被称之为“DNS”，Domain Naming Service。


两台电脑，通过网络连接起来以后，需要使用IO、多线程技术


开发一个简单的、给浏览器使用的服务端

    浏览器就是一个典型的客户端，而淘宝、百度都是属于服务端。
    开发服务端，服务端必须要监听/绑定到一个端口。
    服务端需要不停接收来自浏览器的数据，服务器永远不会知道浏览器什么时候过来访问。
    接收到浏览器的连接，就需要建立起输入流才能读取浏览器发送到服务器的信息；服务器发送给浏览器的信息，就需要使用输出流！


    步骤
        1.服务器需要监听/绑定一个端口。
            这里使用 8000 端口。

            //创建一个服务器端的Socket，绑定到8000端口
            ServerSocket serverSocket = new ServerSocket( 8000 );

        2.服务器不断接收浏览器的连接
            while( true )
            {
                // 接受浏览器（客户端）的连接，连接建立以后，会得到一个Socket对象。
                // Socket表示两台电脑连接的一个通道。
                Socket socket = serverSocket.accept();
            }
        3.接收到连接以后，需要创建输入流，获取数据

            // 通过Socket通道获取的输入流，可以获取对方发送过来的信息
            InputStream in = socket.getInputStream();

        4.数据处理完成以后，使用输出流把信息返回给浏览器

            // 把数据发送给对方的输出流
            OutputStream out = socket.getOutputStream();



        5.服务器程序开发完成以后，把服务器启动起来。
            服务器启动以后，相当于服务器已经在等待浏览器。
            这个时候，浏览器地址栏输入 http://192.168.10.222:8000



网络上面要进行通讯，意味着有很多各种各样的计算设备。为了让所有这些设备都能够互相通讯，必须要有协议。
在网络上，最基础的两个通讯协议是 TCP/IP 协议。
    TCP  : 传输控制协议，目的是为了提供一个透明化的端对端稳定的传输通道。Socket。
    IP   : 因特网协议，目的是为了提供一个计算终端（设备）寻址能力。提供出来的就是IP地址。

    首先利用IP地址找到对方，然后和对方建立Socket通道。建立通道以后，就可以实现通讯。

    UDP  : 不稳定的数据包，通常用于视频通话、视频聊天。这种场景下，丢失几个帧的视频，对整个过程是没有影响的。
        也是一种传输协议，但是和TCP不同。
        TCP是稳定的、有确认包的；UDP基本上也是稳定的、不需要确认包。UDP在大量数据的情况下性能更好，但是可能丢数据。


    上面三个协议，都是为了解决通讯的问题的。


不同的产品、应用，需要有各自的应用层协议。
    比如浏览器专门使用HTTP协议和服务器进行数据的交互。HTTP就是一种应用层协议，它不能直接在网络上传输，必须依赖传输协议，比如TCP。


    HTTP协议，翻译为“超文本传输协议”，是一种基于字符的、和网络无关的应用层协议。负责组织浏览器能够识别的信息。


HTTP协议简介
    HTTP是基于“请求-响应”模式的，先有请求，才有响应。
    浏览器发出请求，服务器接收到【请求消息(requeest)】以后，对请求进行处理。
    服务器处理完请求以后，生成【响应消息(response)】给浏览器。


    请求消息
----------------------------------------------------------------------------------------------------
GET / HTTP/1.1
Host: 127.0.0.1:8000
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.134 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: en-US,en;q=0.8
Cookie: __hstc=19301799.cd6067ae1778f32d61bd4a3bffbadd4b.1464509248993.1464509248993.1464509248993.1; hsfirstvisit=http%3A%2F%2F127.0.0.1%3A8081%2Fnexus%2Fservice%2Flocal%2Foutreach%2Fwelcome%2F%3Fversion%3D2.12.0-01%26versionMm%3D2.12%26edition%3DOSS%26usertype%3Danonymous|http%3A%2F%2F127.0.0.1%3A8081%2Fnexus%2F|1464509248990; hubspotutk=cd6067ae1778f32d61bd4a3bffbadd4b

----------------------------------------------------------------------------------------------------
请求行
请求头
请求头
请求头
请求头
空行
----------------------------------------------------------------------------------------------------

    每行表示一个特殊的参数，行与行之间使用 \r\n 进行分隔。


    请求行
        GET / HTTP/1.1
        请求方式 请求的URI 协议版本

        请求方式
            GET    : 获取数据，浏览器直接在地址栏输入URL然后回车，就是发送GET请求到服务器。点击超级链接、每个图片也都是GET请求
            POST   : 提交数据，比如注册用户、登陆、提交订单，等都是POST请求。这时候往往会新增数据。

            PUT    : 提交数据，往往是修改数据。浏览器不能直接发送此请求，需要使用JavaScript来发送。高级技术！
            DELETE : 删除数据，浏览器不能直接发送，要通过JavaScript来发送。高级技术！
            HEAD   : 只返回响应头，不要有响应体。通常用于数据检查。浏览器不能直接发送。高级技术！

        请求的URI
            URL : 统一资源定位符，用于在全网标识一个唯一的资源的一个字符串。
                http://127.0.0.1:8000/a/index.html  这就是一个URL！
            URI : 统一资源标识符，用于在服务器内部作为一个资源的标识符。文件的路径。
                /a/index.html 在URL里面端口号后面的就是URI。

        协议版本
            目前只有 HTTP/1.1



        请求头
            Host  : 访问的主机名称。http://127.0.0.1:8000/
            User-Agent　: 浏览器版本

        请求头后面的空行
            空行是必须的，表示请求头结束。


        在空行后，如果是POST和PUT请求，还会有请求体。就是提交到服务器的具体的数据。
        如果有请求体，那么一定要有 Content-Length 请求头，用来表明请求体的长度。


    响应消息
----------------------------------------------------------------------------------------------------
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 5

12345
----------------------------------------------------------------------------------------------------
状态行
响应头
响应头

响应体
----------------------------------------------------------------------------------------------------

    状态行
        HTTP/1.1 200 OK
        协议版本 状态码 状态描述

        协议版本只有1.1
        状态码：
            200  表示正常，没有任何问题
            404  表示文件没有找到

        状态描述
            就是一个字符串，但是不能有中文。


    响应头
        Content-Type 表示内容的类型。
            text/html;charset=UTF-8
            表示内容是text格式的，子类型是html。既然是文字，就一定有字符编码的，所以charset表示指定服务器返回给浏览器的内容的字符编码。


        Content-Length 表示响应体的长度，以字节记。




下一步优化
    原来请求HTTP服务器的时候，没有响应。
    接着请求服务器的时候有响应，但是任何的URL到服务器，返回的内容都一样的！

    现在需要优化：
        根据请求的URI找到硬盘上某个目录下的对应的文件。
        把文件的内容作为响应返回给浏览器。


    步骤：
        1.合并请求和响应两个服务端的程序，命名为 SimpleHttpServer
            http://127.0.0.1:8000/a/index.html
        2.在处理Socket的时候，先把请求里面的URI找出来
            /a/index.html
        3.根据找出的URI，创建一个File对象，File对象作为硬盘上某个文件夹的子文件来创建。
            File file = new File("d:/http/", uri);

        4.创建一个文件输入流，把文件输入流里面的数据复制到Socket的输出流。

            try(FileInputStream in = new FileInputStream( file );
                OutputStream out = socket.getOutputStream();
                )
            {
                byte[] data = new byte[1024];

                int c = in.read( data );
                while ( c != -1 )
                {

                    out.write( data, 0, c );

                    c = in.read( data );
                }
            }


            //如果使用Java 7代码会更简单
            URI u = file.toURI();
            Path source = Paths.get( u );
            try( OutputStream out = socket.getOutputStream() )
            {
                Files.copy( source, out );
            }

        5.在执行第四步之前，需要增加一个判断，检查file是否存在。
            如果不存在，需要返回404错误给浏览器！
            如果存在，则执行第四步。



HTTP的Content-Type简介
    Content-Type 也叫做 MIME-Type。MIME-Type。

    html和htm结尾的文件，Content-Type都是  text/html


    MIME-type  扩展名 多个使用空格隔开
    text/plain txt text TXT

    image/jpeg jpg jpeg
    image/gif gif
    image/png png
    image/x-icon icon

    text/css css CSS
    text/javascript js JS
    application/xml xml


    需要根据文件的名称，自动识别文件的类。

    1.需要创建一个 MimetypesFileTypeMap 实例，并且手动加入一些映射。
    2.在发送文件之前，先到 MimetypesFileTypeMap 获取Content-Type



线程池
    预先初始化多个线程，这些线程不会结束。
    需要的时候，从池子里面获取一个线程出来，然后让线程执行任务。
    执行完任务以后，线程处于待命状态，并不会结束。并且返回池子。

    好处是：线程对象可以被重复使用，大大降低了创建线程的代价。
        在多线程的环境，能够有效提高程序的性能。


    在JDK里面，自带了性能非常优秀的线程池。
        ExecutorService 是线程池的接口，通常里 Executors 类来创建实例。

        1.创建线程池，线程池一定是成员变量，共用的！

            //创建最多50个线程的线程池，一般来讲线程池的数量都是需要根据系统的实际运行情况来调整的。
            ExecutorService es = Executors.newFixedThreadPool( 50 );

        2.把要处理的任务放到Runnable的实现类里面。
            可以使用Lambda表达式传入代码给submit方法。

            es.submit( () -> {
                //任务的内容
            });


    线程池里面的线程永远不会结束，所以在结束程序的时候，必须要调用shutdown方法停止线程池以后，程序才能正常结束。


    假设现在线程池的大小是50，而系统最优同时执行线程的数量，正好也是50。
    这样意味着，线程池已经最优化！
    此时突然有1000个用户涌入来执行任务。用户的任务，远远超出线程池容量和系统的处理能力之外。
    使用线程池的时候，有一个非常重要的好处：超出线程池容量的任务，不会被马上执行，而是会进行排队。
    排队的时候，需要先等前面在执行的任务完成以后，后面排队的任务才会继续执行。
    这样可以确保程序永远在【最优化】的情况下运行。




重点
    1.服务器Socket的通讯
    2.实现简单的HTTP服务器




下次课的主要内容提要
    1.了解NIO下的网络通讯
    2.同时实现服务器和客户端，开发聊天程序







