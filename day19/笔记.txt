NIO
    ServerSocketChannel : 服务端的、用于绑定端口的一个Socket通道。类似于ServerSocket。
    SocketChannel       : 客户端和服务端连接成功以后，会产生的一个端对端的通道。类似于Socket。
    Selector            : NIO是基于事件的方式来驱动业务的，哪些事件要处理呢？在通道里面注册选择以后，利用Selector可以选取需要处理的事件。
    SelectionKey        : 相当于就是选择的事件的名称。


    使用NIO开发HTTP服务器步骤
        1.打开ServerSocketChannel
            ServerSocketChannel serverChannel = ServerSocketChannel.open();

        2.设置Socket的参数
            默认情况下可以不设置，参数只是为了优化性能。

            setOption是设置性能优化选项的方法，可以省略。


            为了实现选择的能力，必须要配置一个参数：

            //表示配置非阻塞IO，NIO最直接的性能提升，就是非阻塞IO。
            //如果没有配置这个参数，那么后面的选择器无法正常选择。
            serverChannel.configureBlocking( false );

        3.绑定端口
            InetSocketAddress port = new InetSocketAddress(8000);
            serverChannel.bind( port );


        4.注册选择事件
            //打开一个选择器
            Selector selector = Selector.open();

            //注册连接操作，如果有连接操作，则进行处理
            serverChannel.register( selector, SelectionKey.OP_ACCEPT );


            //选择注册完成以后，就可以接受浏览器的连接，往往需要启动一个线程不断select，选择事件来进行处理



聊天程序的登陆过程分析
    1.使用登陆界面输入的IP，连接到服务器。统一使用8000的端口。
    2.连接服务器的动作，应该是在点击“登陆”按钮的时候执行的！
    3.连接到服务器以后，需要把昵称发送给服务器，告诉服务器客户端的身份。

    4.服务器收到连接以后，就需要不断等待客户端的昵称（登陆消息）。
    5.服务器收到登陆消息以后，就给客户端返回一个登陆成功的消息。返回之前，需要判断昵称是否存在；如果存在则返回登陆失败。
    6.登陆成功以后，同时还需要给所有的客户端发送欢迎消息。让所有人都知道谁来了！
    7.欢迎消息发送完成以后，需要为所有的用户广播更新的用户列表。

    8.客户端登陆以后，显示聊天界面，这时候用户可以发送信息，进行群聊。
        群聊的时候，客户端发送聊天信息给服务器。

    9.服务器收到聊天信息以后，就需要把聊天信息广播给所有的在线用户。
        如果某个用户发送失败，则认为此用户已经离线，需要执行用户离线的动作。

    10.用户可以在客户端发送信息主动告诉服务器，客户端要离线（点击关闭按钮的时候）。
        服务器收到离线信息，执行离线动作。

    11.离线动作的过程：
        服务器关闭此客户端对应的Socket连接。
        为所有的其他在线用户，广播用户离线信息。
        为所有的其他在线用户，广播最小的用户列表。


    消息的类型
        11 登陆消息
        12 客户端发送的聊天消息
        13 客户端发送的用户离开消息

        21 登陆成功消息
        22 登陆失败消息
        23 登陆欢迎消息
        24 用户列表更新消息
        25 服务器广播的聊天消息
        26 服务端广播的用户离线消息


    确定了消息类型以后，就需要有一个Message对象！

        public class Message
        {
            /**
                消息类型
            */
            private int type;

            /**
                消息的发送者，比如张三发送的、系统发送的
            */
            private String sender;

            /**
                发送时间，统一以服务器时间为准
            */
            private Date sendTime;


            /**
                消息的文本内容，使用UTF-8的方式进行解码的！
            */
            private String textContent;
        }



    需要开发一个非常简单的服务器，和一个非常简单的客户端。
        服务器监听8000端口，不断使用ProtocolHandler接收信息。
        客户端则连接到服务器的8000端口，使用ProtocolHandler发送一个信息出去。

        客户端发送的信息，服务器应该能够收到，并且丝毫不差！



DataInputStream
    readInt    : 会连续读取四个字节，然后自动把四个字节的数据，转换为int。
        第一次readInt，表示消息类型。
        第二次readInt，表示消息里面一个String的长度
        利用得到的长度new一个byte数组

    readFuly   : 此方法读取数据的时候，会把整个byte数组填满，如果没有填满，会自动等待！


DataOutputStream
    writeInt   : 参数如果是一个int，会连续写出四个字节。一个int最多需要四个字节。
        消息类型，使用writeInt方法来进行发送。
        但是无法使用此方法发送消息的内容，因为内容的长度不定！
        内容长度不定，只能通过发送内容的长度来进行协商。Content-Length。
        长度，也是一个int，通过此方法发送。

    write      : 可以直接把byte数组全部写出。但是在写出byte数组之前，需要先写出一个数组的长度。





实现步骤：
    1.确保ProtocolHandler可以正常收发信息。
        客户端发送一个登陆信息给服务器，服务器能够正常收到并打印即可。


    2.修改服务器
        收到登陆信息以后，应该返回欢迎登陆成功、失败消息
        登陆成功还需要广播欢迎消息、用户列表

















